/*   Copyright (C) 2003 Finalist IT Group
 *
 *   This file is part of JAG - the Java J2EE Application Generator
 *
 *   JAG is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *   JAG is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   You should have received a copy of the GNU General Public License
 *   along with JAG; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.finalist.jag.template.parser;

/* Generated by Together */

/**
 * Class JagParser
 *
 * Generates a tree structure for a jag template file.
 *
 * @author Wendel D. de Witte
 * @version %I%, %G%
 */
public class JagParser implements JagParserConstants {

   /** Field input */
   private CharBuffer input = null;

   /** Field lnkJagBlockCollection */
   private JagBlockCollection lnkJagBlockCollection = null;

   /** Field tagDefBegin */
   private String tagDefBegin = null;

   /** Field tagDefEnd */
   private String tagDefEnd = null;

   /** Field tagDefClose */
   private String tagDefClose = null;

   /** Field tagDefClose */
   private String tagDefBodyClose = null;

   /** Field currentBlock */
   private JagBlockImpl currentBlock = null;


   /**
    * Constructor JagParser
    *
    *
    */
   public JagParser() {
   }


   /**
    * Method process
    *
    *
    * @param input
    *
    * @return
    *
    */
   public boolean process(CharBuffer input) {
      // Initialize the tag definitions
      tagDefBegin = getTokenString(TAGDEF_BEGIN);
      tagDefEnd = getTokenString(TAGDEF_END);
      tagDefClose = getTokenString(TAGDEF_CLOSE) + tagDefEnd;
      tagDefBodyClose = getTokenString(TAGDEF_BEGIN) + getTokenString(TAGDEF_CLOSE);
      lnkJagBlockCollection = new JagBlockCollection();
      currentBlock = lnkJagBlockCollection;
      this.input = input;

      // Buffer for holding the text between the tags.
      StringBuffer text = new StringBuffer();

      try {
         // todo : header exception when they appear after a tag definition.
         boolean expandBuffer = true;
         while (EOF_CHAR != input.LA(1)) {
            // process header.
            if (isHeaderDefinition()) {
               expandBuffer = !processHeader();
               text = new StringBuffer();
            } else if (isCommentDefinition()) {
               consumeComment();
            }
            // process tag
            else if (isTagDefinition()) {
               insertTextBlock(currentBlock, new String(text));
               text = new StringBuffer();
               // ignore the false return value, should be handle
               // by the processor of the tree structure.
               expandBuffer = !processTag();
            }
            // expand text buffer
            if (expandBuffer) {
               text.append(input.LA(1));
               input.consume();
            }
            expandBuffer = true;
         }
      } catch (Exception e) {
      }
      // Insert the remaining textBlock.
      insertTextBlock(currentBlock, new String(text));
      return false;
   }


   /**
    * Method process
    *
    * @return
    */
   public boolean processTagBody() throws CharStreamException, JagParserException {
      StringBuffer text = new StringBuffer();
      boolean expandBuffer = true;
      while (EOF_CHAR != input.LA(1)) {
         // process end of tagbody.
         if (isTagDefBodyClose()) {
            insertTextBlock(currentBlock, new String(text));
            text = new StringBuffer();
            return true;
         } else if (isCommentDefinition()) {
            consumeComment();
         }
         // process inner tag
         else if (isTagDefinition()) {
            insertTextBlock(currentBlock, new String(text));
            text = new StringBuffer();
            expandBuffer = !processTag();
         }

         // expand text block
         if (expandBuffer) {
            text.append(input.LA(1));
            input.consume();
         }
         expandBuffer = true;
      }
      // Insert the remaining textBlock.
      insertTextBlock(currentBlock, new String(text));
      return false;
   }


   /**
    * Method insertTextBlock
    *
    * Inserts a textblock. Invalid textblocks are ignored.
    * A textblock is invalid if the first character is an eol symbol
    * or the string is empty.
    *
    * @param parent
    * @param text
    *
    */
   protected void insertTextBlock(JagBlock parent, String text) {
      if (text.length() > 0 && text.charAt(0) != EOF_CHAR) {
         JagBlockImpl blockChild = new JagBlockImpl();
         blockChild.initialize(TEXT, new String(text));
         parent.addChild(blockChild);
      }
   }


   /**
    * Method processHeader
    *
    *
    * @return
    *
    */
   protected boolean processHeader() {
      int mark = input.mark();
      try {
         match(HEADERDEF_BEGIN);
         // start
         JagBlockImpl block = new JagBlockImpl();
         block.initialize(HEADERDEF_BEGIN, "HEADERDEF_BEGIN");
         currentBlock.addChild(block);
         processParameters(block);
         retrieveDataFromHeader(block);
         consumeSpaces();
         // end
         match(HEADERDEF_END);
         return true;
      }
            // reset in case of an exception
      catch (CharStreamException exc) {
         input.rewind(mark);
      } catch (JagParserException exc) {
         input.rewind(mark);
      }
      input.commit();
      return false;
   }


   /**
    * Method retrieveDataFromHeader
    *
    * Re-initialize the tag definitions. Gives the user an option to define
    * the tag definition (start/end symbol) in header of the template. This
    * to prevent incompatibilities between other tags. (jsp, html etc)
    */
   protected void retrieveDataFromHeader(JagBlock headerBlock) {
      if (headerBlock.getType() != HEADERDEF_BEGIN)
         return;

      JagBlock childBlock = headerBlock.getFirstChild();
      while (childBlock != null) {
         if (childBlock.getType() == PARAMDEF) {
            JagBlock childBlock2 = childBlock.getFirstChild();
            if (childBlock2 != null && childBlock2.getType() == IDENT) {
               if (childBlock2.getText().equals(getTokenString(TAGSTART))) {
                  childBlock2 = childBlock2.getNextSibling();
                  if (childBlock2 != null) {
                     tagDefBegin = childBlock2.getText();
                     tagDefBodyClose = tagDefBegin + getTokenString(TAGDEF_CLOSE);
                  }
               } else if (childBlock2.getText().equals(getTokenString(TAGEND))) {
                  childBlock2 = childBlock2.getNextSibling();
                  if (childBlock2 != null) {
                     tagDefEnd = childBlock2.getText();
                     tagDefClose = getTokenString(TAGDEF_CLOSE) + tagDefEnd;
                  }
               }
            }
         }
         childBlock = childBlock.getNextSibling();
      }
   }


   /**
    * Method processTag
    *
    * Works with processTagBody()
    * @return
    *
    */
   protected boolean processTag() {
      JagBlockImpl prevCurrentBlock = currentBlock;
      int mark = input.mark();
      try {
         match(tagDefBegin);
         JagBlockImpl blockTag = new JagBlockImpl();
         blockTag.initialize(TAGSTART, "TAGSTART");

         JagBlock endtagname = processIdent(TAGNAME);
         blockTag.addChild(endtagname);
         match(COLON);
         JagBlock endtagaction = processIdent(TAGACTION);
         blockTag.addChild(endtagaction);
         processParameters(blockTag);

         consumeSpaces();
         if (ismatch(tagDefClose)) {
            match(tagDefClose);
            blockTag.setText(input.getCharsFromMark(mark));
            currentBlock.addChild(blockTag);
         } else {
            match(tagDefEnd);
            blockTag.setText(input.getCharsFromMark(mark));

            // Insert TagBody
            JagBlockImpl blockSlist = new JagBlockImpl();
            blockSlist.initialize(SLIST, getTokenString(SLIST));
            blockTag.addChild(blockSlist);
            currentBlock = blockSlist;

            // Process the tagbody
            if (!processTagBody())
               throw new JagParserException("Closing tag expected");

            // Process the closing tag
            int mark2 = input.mark();
            match(tagDefBodyClose);
            if (!endtagname.equals(processIdent(TAGNAME)))
               throw new JagParserException("Invalid tag name in closing tag");
            match(COLON);
            if (!endtagaction.equals(processIdent(TAGACTION)))
               throw new JagParserException("Infinite tag in closing tag");
            match(tagDefEnd);

            // insert end block
            JagBlockImpl blockBodyEndTag = new JagBlockImpl();
            blockBodyEndTag.initialize(TAGEND, input.getCharsFromMark(mark2));
            blockTag.addChild(blockBodyEndTag);

            // restore currentblock;
            currentBlock = prevCurrentBlock;
            currentBlock.addChild(blockTag);
            // discard mark2
            input.commit();
         }
         input.commit();
         return true;
      } catch (CharStreamException exc) {
         input.rewind(mark);
         currentBlock = prevCurrentBlock;
      } catch (JagParserException exc) {
         input.rewind(mark);
         currentBlock = prevCurrentBlock;
      }
      return false;
   }


   /**
    * Method processParameters
    *
    *
    * @param blockRoot
    *
    * @throws CharStreamException
    * @throws JagParserException
    *
    */
   protected void processParameters(JagBlock blockRoot)
         throws CharStreamException, JagParserException {
      while (true) {
         consumeSpaces();
         StringBuffer text = new StringBuffer();
         while (Character.isLetter(input.LA(1)) || (input.LA(1) == '_')) {
            text.append(input.LA(1));
            input.consume();
         }
         if (text.length() == 0) {
            return;
         }

         consumeSpaces();

         if (!ismatch(ASSIGN)) {
            JagBlockImpl blockChild = new JagBlockImpl();
            blockChild.initialize(IDENT, new String(text));
            blockRoot.addChild(blockChild);
            continue;
         }

         match(ASSIGN);

         JagBlockImpl blockParamDef = new JagBlockImpl();
         blockParamDef.initialize(PARAMDEF, getTokenString(PARAMDEF));
         blockRoot.addChild(blockParamDef);

         JagBlockImpl blockChild = new JagBlockImpl();
         blockChild.initialize(IDENT, new String(text));
         blockParamDef.addChild(blockChild);
         consumeSpaces();

         text = new StringBuffer();

         if ((input.LA(1) == '"') && (input.LA(0) != '\\')) {
            match("\"");
            while (!((input.LA(1) == '"') && (input.LA(0) != '\\'))) {
               text.append(input.LA(1));
               input.consume();
            }
            match("\"");

            JagBlockImpl blockString = new JagBlockImpl();

            blockString.initialize(STRING, new String(text));
            blockParamDef.addChild(blockString);
         } else if ((input.LA(1) == '\'') && (input.LA(0) != '\\')) {
            match("'");
            while (!((input.LA(1) == '\'') && (input.LA(0) != '\\'))) {
               text.append(input.LA(1));
               input.consume();
            }
            match("'");

            JagBlockImpl blockString = new JagBlockImpl();

            blockString.initialize(STRING, new String(text));
            blockParamDef.addChild(blockString);
         } else {
            boolean bInteger = true;
            boolean bFloat = true;

            while (Character.isDigit(input.LA(1))
                  || Character.isLetter(input.LA(1))
                  || (input.LA(1) == '_') || (input.LA(1) == '.')) {
               if (!Character.isDigit(input.LA(1)) && (input.LA(1) != '.')) {
                  bInteger = false;
                  bFloat = false;
               } else if (!Character.isDigit(input.LA(1))) {
                  bInteger = false;
               }

               text.append(input.LA(1));
               input.consume();
            }

            if (text.length() > 0) {
               JagBlockImpl block = new JagBlockImpl();

               block.initialize(bInteger ? INTEGER : bFloat ? FLOAT : STRING, new String(text));
               blockParamDef.addChild(block);
            } else {
               throw new JagParserException("Invalid parameter definition");
            }
         }
      }
   }


   protected JagBlock processIdent(int tagtype)
         throws CharStreamException, JagParserException {
      StringBuffer text = new StringBuffer();
      while (Character.isLetter(input.LA(1)) || (input.LA(1) == '_')) {
         text.append(input.LA(1));
         input.consume();
      }
      if (text.length() < 1)
         throw new JagParserException("Identifier expected");

      JagBlockImpl blockChild = new JagBlockImpl();
      blockChild.initialize(tagtype, new String(text));
      return blockChild;
   }


   /**
    * Method consumeComment
    *
    * @throws CharStreamException
    * @throws JagParserException
    */
   protected void consumeComment()
         throws CharStreamException, JagParserException {
      match(tagDefBegin + getTokenString(COMMENT_BEGIN));
      while (EOF_CHAR != input.LA(1) && !ismatch(getTokenString(COMMENT_END) + tagDefBegin)) {
         input.consume();
      }
      match(getTokenString(COMMENT_END) + tagDefBegin);
   }


   /**
    * Method isTagDefinition
    *
    *
    * @return
    *
    */
   protected boolean isTagDefinition() {
      return ismatch(tagDefBegin) && !ismatch(tagDefEnd);
   }


   /**
    * Method isHeaderDefinition
    *
    *
    * @return
    *
    */
   protected boolean isHeaderDefinition() {
      return ismatch(HEADERDEF_BEGIN);
   }


   /**
    * Method isCommentDefinition
    *
    *
    * @return
    *
    */
   protected boolean isCommentDefinition() {
      return ismatch(tagDefBegin + getTokenString(COMMENT_BEGIN));
   }


   /**
    * Method isTagDefBodyClose
    *
    *
    * @return
    *
    */
   protected boolean isTagDefBodyClose() {

      if (!ismatch(tagDefBodyClose))
         return false;

      int mark = input.mark();
      boolean returnValue = true;
      try {
         match(tagDefBodyClose);
         processIdent(TAGNAME);
         match(COLON);
         processIdent(TAGACTION);
         match(tagDefEnd);
      } catch (Exception e) {
         returnValue = false;
      }
      input.rewind(mark);
      return returnValue;
   }


   /**
    * Method getJagBlockCollection
    *
    *
    * @return
    *
    */
   public final JagBlockCollection getJagBlockCollection() {
      return lnkJagBlockCollection;
   }


   /**
    * Method consumeSpaces
    *
    *
    * @return
    *
    * @throws CharStreamException
    * @throws JagParserException
    *
    */
   protected int consumeSpaces() throws CharStreamException, JagParserException {
      int nCounter = 0;

      while (true) {
         if (Character.isWhitespace(input.LA(1)) || (input.LA(1) == '\n')) {
            input.consume();
            nCounter++;
         } else if (input.LAChars(2) == "\r\n") {
            match("\r\n");
            nCounter += 2;
         } else {
            break;
         }
      }

      return nCounter;
   }


   /**
    * Method match
    *
    *
    * @param token
    *
    * @throws CharStreamException
    * @throws JagParserException
    *
    */
   protected void match(int token) throws CharStreamException, JagParserException {
      match(getTokenString(token));
   }


   /**
    * Method match
    *
    *
    * @param s
    *
    * @throws CharStreamException
    * @throws JagParserException
    *
    */
   protected void match(String s) throws CharStreamException, JagParserException {
      StringBuffer text = new StringBuffer();

      for (int i = 0; i < s.length(); i++) {
         text.append(input.LA(1));

         if (s.charAt(i) != input.LA(1)) {
            throw new JagParserException("\" " + s
                  + " \" excpected, found \" "
                  + text.toString() + " \"");
         }
         input.consume();
      }
   }


   /**
    * Method ismatch
    *
    *
    * @param token
    *
    * @return
    *
    */
   protected boolean ismatch(int token) {
      return ismatch(getTokenString(token));
   }


   /**
    * Method ismatch
    *
    *
    * @param s
    *
    * @return
    *
    */
   protected boolean ismatch(String s) {
      try {
         String sChars = input.LAChars(s.length());
         return sChars.compareTo(s) == 0;
      } catch (CharStreamException exc) {
      }

      return false;
   }


   /**
    * Method getTokenString
    *
    *
    * @param n
    *
    * @return
    *
    */
   protected String getTokenString(int n) {
      return tokennames[n];
   }
}

;