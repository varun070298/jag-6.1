/*
 * SkeletValidator.java
 *
 * Created on November 25, 2004, 1:10 PM
 */

package com.finalist.jaggenerator;

import com.finalist.jaggenerator.modules.*;

import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.util.*;

/**
 * @author Rudie Ekkelenkamp.
 */
public class SkeletValidator {
    private Root root = null;
    private javax.swing.JTree tree = null;
    private ConsoleLogger logger = null;
    private HashMap entitiesByTableName = null;

    /**
     * Creates a new instance of SkeletValidator
     */
    public SkeletValidator(Root root, javax.swing.JTree tree, HashMap entitiesByTableName, ConsoleLogger logger) {
        this.root = root;
        this.tree = tree;
        this.logger = logger;
        this.entitiesByTableName = entitiesByTableName;
    }


    /**
     * Check on projectname, description, datasource name, jndi-name and mapping, etc..
     *
     * @return null if valid, returns a message string in case of an error.
     */
    public String validateSkelet() {
        boolean atLeastOneCompositePK = false;
        boolean valid = true;
        boolean autoGeneratedStringInvalidHibernate = false;
        boolean isRelatedEntityComposite = false;
        String message = "";
        String businessTier = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_BUSINESS_TIER);
        String webTier = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_WEB_TIER);        
        String appServer = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_APPLICATION_SERVER);
        String useJava5 = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_JAVA5);

        // Do some basic checks before generation starts.
        try {
            // Make sure the projectname has been set!
            if (root.app.nameText.getText() == null || "".equals(root.app.nameText.getText())) {
                valid = false;
                message += "No valid application name has been set in the 'Application settings'.\r\n";
            } else if (!root.app.nameText.getText().toLowerCase().equals(root.app.nameText.getText())) {
                // Check if it is a valid name! Should be lowercase only!
                valid = false;
                message += "No valid application name in the 'Application settings'. Should be only lowercase!.\r\n";
            }
        } catch (Exception e) {
            valid = false;
            message += "No valid application name has been set in the 'Application settings'.\r\n";
        }

        try {
            // Make sure the applicationname has been set!
            if (root.app.descriptionText.getText() == null || "".equals(root.app.descriptionText.getText())) {
                valid = false;
                message += "No valid application description has been set in the 'Application settings'.\r\n";
            } else {
                // Check if the first character is uppercase!
                String firstChar = root.app.descriptionText.getText().substring(0, 1);
                if (!firstChar.toUpperCase().equals(firstChar)) {
                    valid = false;
                    message += "No valid application description has been set in the 'Application settings'. First character should be uppercase!\r\n";
                }
            }
        } catch (Exception e) {
            valid = false;
            message += "No valid application description has been set in the 'Application settings'.\r\n";
        }

        try {
            // Make sure the rootpackage has been set!
            if (root.app.rootPackageText.getText() == null || "".equals(root.app.rootPackageText.getText())) {
                valid = false;
                message += "No valid root package set in the 'Application settings'.\r\n";
            }
        } catch (Exception e) {
            valid = false;
            message += "No valid root package set in the 'Application settings'.\r\n";
        }

        try {
            // Make sure the applicationname has been set!
            if (root.datasource.jdbcURLCombo.getSelectedItem() == null || "".equals(root.datasource.jdbcURLCombo.getSelectedItem())) {
                valid = false;
                message += "No valid datasource URL set in the Datasource form.\r\n";
            }
        } catch (Exception e) {
            valid = false;
            message += "No valid datasource URL set in the Datasource form.\r\n";
        }

        try {
            // Make sure the datasource has been set!
            if (root.datasource.jndiText.getText() == null || "".equals(root.datasource.jndiText.getText()) || "jdbc/".equals(root.datasource.jndiText.getText())) {
                valid = false;
                message += "No valid datasource jndi-name set in the Datasource form.\r\n";
            }
        } catch (Exception e) {
            valid = false;
            message += "No valid datasource jndi-name set in the Datasource form.\r\n";
        }


        HashMap entityRefs = new HashMap();
        ArrayList el = root.getEntityEjbs();
        for (int i = 0; i < el.size(); i++) {
            Entity e = (Entity) el.get(i);
            // Create a hashmap with all current entity refs.
            entityRefs.put(e.getRefName(), null);
        }

        // Check if there have been entities marked as association entities without having 2 foreign keys.
        for (int i = 0; i < el.size(); i++) {
            Entity entity = (Entity) el.get(i);
            if ("true".equals(entity.getIsAssociationEntity())) {
                // Now check if it is a valid association entity.
                if (entity.getRelations() != null && entity.getRelations().size() == 2 && entity.getFields().size() == 2) {
                    // It's an entity with exaclty 2 foreign keys (targetMultiple is false).
                    if (((Relation) entity.getRelations().get(0)).isTargetMultiple() &&
                            ((Relation) entity.getRelations().get(1)).isTargetMultiple()
                            ) {
                        // OK, it's a valid association.
                    } else {
                        // Both relation should be many-to-one relations.
                        valid = false;
                        message += "Entity " + entity.getName() + " is not a valid assocation Entity.\r\nThere should be exactly 2 many-to-one relations in the assocation entity.\r\n";
                    }
                } else {
                    // Not valid. Exactly 2 forein keys are required.
                    valid = false;
                    message += "Entity " + entity.getName() + " is not a valid assocation Entity.\r\nThere should be exactly 2 many-to-one relations in the assocation entity.\r\n";
                }
            }


        }

        // Validate that the entity beans 'within' the session beans actually exist..
        try {
            ArrayList sl = root.getSessionEjbs();
            for (int i = 0; i < sl.size(); i++) {
                Session s = (Session) sl.get(i);
                ArrayList allRefs = s.getEntityRefs();
                for (int j = 0; j < allRefs.size(); j++) {
                    if (!entityRefs.containsKey(allRefs.get(j))) {
                        valid = false;
                        message += "The reference " + allRefs.get(j) + " in Service Bean " + s.getRefName() + " doesn't exist .\r\n";
                    }
                }
                // Make sure that all the entity refs are defined!
            }
        } catch (Exception e) {
            valid = false;
            message += "Error in Service Bean.\r\n";
        }

        // Validate the Primary Keys on the Entity EJBs and composite primary keys.!
        try {
            // Make sure the applicationname has been set!
            ArrayList nl = root.getEntityEjbs();
            for (int i = 0; i < nl.size(); i++) {
                Entity e = (Entity) nl.get(i);
                List relations = e.getRelations();
                for (int r = 0; r < relations.size(); r++) {
                    Relation relation = (Relation) relations.get(r);
                    if (relation.getRelatedEntity().isCompositeKey()) {
                        // The target entity of a relation shouldn't be a composite.
                        // JAG doesn't support this.
                        isRelatedEntityComposite = true;
                    }

                }
                //Make sure that a display name maps one of its fields.
                String displayName = "";
                boolean validDisplayName = false;
                if (e.getDisplayName() == null || "".equals(e.getDisplayName().toString())) {
                    // Always valid if not set.
                    validDisplayName = true;
                } else {
                    displayName = e.getDisplayName().toString();
                }
                
                // Iterate over all entity fields. Make sure that autoGeneratedCheckBox has not been
                // Marked for foreign keys.
                List fields = e.getFields();
                for (int j = 0; j < fields.size(); j++) {
                    Field field = (Field) fields.get(j);
                    if (displayName.equals(field.getName().toString())) {
                        validDisplayName = true;
                    }
                    if (field.autoGeneratedCheckBox.isSelected() && field.foreignKeyCheckBox.isSelected() && "false".equals(e.getIsAssociationEntity()) ) {
                        logger.log("Field: " + field.getName() + " of entity : " + e.getName() + " cannot have autogenerated primary key selected and be a foreign key!");
                        valid = false;
                        message += "Field: " + field.getName() + " of entity : " + e.getName() + " cannot have autogenerated primary key selected and be a foreign key!.\r\n";
                    }
                    if (field.autoGeneratedCheckBox.isSelected()) {
                        if ("java.lang.String".equalsIgnoreCase(field.getType())) {
                            // In this case, check the size.
                            // For the hibernate uuid.hex generator, the size should be >= 32
                            String fieldSize = field.getSize();
                            try {
                                int size = Integer.parseInt(fieldSize);
                                if (size < 32) {
                                    autoGeneratedStringInvalidHibernate = true;
                                }
                            } catch (Exception ex) {
                                // Size could not be determined.
                                // Assume that size was not set and the size will be large enough.
                            }
                        }
                    }

                }
                if (!validDisplayName) {
                    // No valid name found for the display name.
                    logger.log("No valid display name set: " + displayName);
                    valid = false;
                    message += "Display name " + displayName + " of entity : " + e.getName() + " should be a field of this entity.";
                }
                if (e.isCompositeCombo.getSelectedItem().equals("true") && e.isAssociationEntity.getSelectedItem().equals("false")) {
                    // If composite is set to true,
                    // The primary key type should be set, the primary key field should be empty
                    // and the number of fields marked as primary key should be > 1.

                    atLeastOneCompositePK = true;

                    if (e.pKeyTypeText.getText() == null || e.pKeyTypeText.getText().equals("")) {
                        // The primary key type is empty! This is an error!
                        logger.log("Primary key type is empty, but should be set since composite primary key has been set to true for Entity EJB: " + e.getRefName());
                        valid = false;
                        message += "Primary key type is empty, but should be set since composite primary key has been set to true for Entity EJB: " + e.getRefName() + ".\r\n";
                    }

                    if (e.pKeyText.getText() != null && !e.pKeyText.getText().equals("")) {
                        // The primary key type is empty! This is an error!
                        logger.log("Primary key should be empty since the since composite primary key has been set to true for Entity EJB: " + e.getRefName());
                        valid = false;
                        message += "Primary key should be empty, since composite primary key has been set to true for Entity EJB: " + e.getRefName() + ".\r\n";
                    }

                    if (e.countPrimaryKeyFields() <= 1) {
                        logger.log("In the field specifications for Entity EJB: " + e.getRefName() + " there should be more than one field that has been marked as primary key. Now only " + e.countPrimaryKeyFields() + " have been marked as primary key!");
                        valid = false;
                        message += "In the field specifications for Entity EJB: " + e.getRefName() + " there should be more than one field that has been marked as primary key. Now only " + e.countPrimaryKeyFields() + " have been marked as primary key!.\r\n";
                    }

                } else if ((e.isCompositeCombo.getSelectedItem()).equals("false")) {
                    if (e.pKeyTypeText.getText() == null || e.pKeyTypeText.getText().equals("")) {
                        logger.log("No primary key set for entity bean: " + e.getRefName());
                        valid = false;
                        message += "No primary key set for entity bean: " + e.getRefName() + ".\r\n";
                    }

                    if (e.countPrimaryKeyFields() > 1) {
                        // There should be just 1 primary key selected.
                        if (e.countPrimaryKeyFields() > 1) {
                            logger.log("More than 1 primary key declared, while composite primary key is set to false for entity bean '" + e.getRefName() + "' .");
                            valid = false;
                            message += "More than 1 primary key declared, while composite primary key is set to false for entity bean '" + e.getRefName() + "' .\r\n";
                        }
                    }

                    if (e.countPrimaryKeyFields() == 1) {
                        // In this case we can check if the specified primary field and type, match the selected field.
                        String name = e.getFirstPrimaryKeyFieldName();
                        String type = e.getPrimaryKeyClass();

                        if ((name == null) || e.pKeyText.getText() == null || !name.equals(e.pKeyText.getText())) {
                            logger.log("Non-matching primary keys!  In entity bean '" + e.getRefName() + "' the field '" + name + "' has been marked as primary key, yet that entity has primary key '" + e.pKeyText.getText() + "'.");
                            valid = false;
                            message += "Non-matching primary keys!  In entity bean '" + e.getRefName() + "' the field '" + name + "' has been marked as primary key, yet that entity has primary key '" + e.pKeyText.getText() + "'.\r\n";
                        }
                        if ((type == null) || e.pKeyTypeText.getText() == null || !type.equals(e.pKeyTypeText.getText())) {
                            logger.log("Non-matching primary key types!  In entity bean '" + e.getRefName() + "' the field '" + name + "' has been marked as primary key and has type '" + type + "', yet the entity has primary key type '" + e.pKeyTypeText.getText() + "'.");
                            valid = false;
                            message += "Non-matching primary key types!  In entity bean '" + e.getRefName() + "' the field '" + name + "' has been marked as primary key and has type '" + type + "', yet the entity has primary key type '" + e.pKeyTypeText.getText() + "'.\r\n";
                        }
                    }
                }
            }

        } catch (Exception e) {
            valid = false;
            message += "Error in Entity Bean.\r\n";
        }

        //check for duplicate relation names within the same entity bean..
        String badEntity = getEntityWithDuplicateRelationNames();
        if (badEntity != null) {
            valid = false;
            message += "Entity bean " + badEntity + " has more than one relation with the same 'relation name'.\n" +
                    "This is not allowed!  Please rename at least one of the relation names.\r\n";
        }

        //check for relations that reference tables for which there is no entity bean..
        List unreferencedEntities = getEntityWithUnreferencedRelations();
        if (!unreferencedEntities.isEmpty()) {
            valid = false;
            StringBuffer tmp = new StringBuffer();
            Iterator i = unreferencedEntities.iterator();
            while (i.hasNext()) {
                String[] details = (String[]) i.next();
                if (!"".equals(details[2])) {
                    tmp.append("Entity bean '" + details[0] + "' contains a relation '" + details[1] +
                            "' that references a table '" + details[2] + "',\n" +
                            "which doesn't correspond to any entity bean.  Please either:\n" +
                            "\ta) delete the relation,\n" +
                            "\tb) create an entity bean for the table '" + details[2] + "', or\n" +
                            "\tc) in the relation, correct the 'foreign table' value.\r\n");
                }
            }
            message += tmp.toString();
        }

        //check for any relation with empty/invalid data..
        String relationErrorMessage = getRelationWithInvalidData();
        if (relationErrorMessage != null) {
            valid = false;
            message += relationErrorMessage;
        }
        // Check if the related entity is a composite primary key.
        if (isRelatedEntityComposite) {
            String msg = "At least one target entity of a relation has a composite primary key. JAG doesn't support this.\r\n";
            logger.log(msg);
            valid = false;
            message += msg;
        }
        // check if the Container-managed relations checkbox was unchecked BUT some CMRs are still defined!
        String templateValue = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_RELATIONS);
        if ("false".equalsIgnoreCase(templateValue)) {
            // CMR was not selected. Make sure no relations are defined in the model!

            // Now check if there are still some relations defined.
            if (isRelationPresentInModel()) {
                valid = false;
                message += "The Container-managed relations checkbox in the Configuration screen was unchecked,\r\n" +
                        "but there are still relations defined in the project.\r\n" +
                        "Either enable Container-managed relations or remove the relations from the project.\r\n";
            }
        }

        // Check business tier specific validations.
        if (atLeastOneCompositePK) {
            // In case Hibernate 2 was selected, No composites are supported!
            if (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) ||
                    (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier) &&
                            "false".equals(useJava5)
                    )
                    ) {
                logger.log("JAG does not support composite primary keys for Hibernate.");
                valid = false;
                message += "JAG does not support composite primary keys for Hibernate.\r\n";
            }
        }

        if (autoGeneratedStringInvalidHibernate) {
            // In case Hibernate 2 was selected, autogenerated string's should be at least size 32
            if (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) ||
                    JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier)
                    ) {
                String msg = "At least one autogenerated primary key field of type string has size < 32. Hibernate cannot autogenerate this primary key.\r\n";
                logger.log(msg);
                valid = false;
                message += msg;
            }
        }

        // Check application server specific validations.

        if (JagGenerator.TEMPLATE_APPLICATION_SERVER_TOMCAT_5.equalsIgnoreCase(appServer)) {
            // Only Hibernate is supported for deployment on tomcat.
            // All other business tiers are dependent on an EJB container.
            if (!JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) &&
                    !JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier)
                    ) {
                String msg = "Only hibernate can be selected for the Tomcat application server.\r\n";
                logger.log(msg);
                valid = false;
                message += msg;
            }

        }

        if (!JagGenerator.TEMPLATE_APPLICATION_SERVER_JBOSS_4_X.equalsIgnoreCase(appServer)) {
            if (JagGenerator.TEMPLATE_BUSINESS_TIER_EJB3.equalsIgnoreCase(businessTier)) {
                // EJB3 is currently only supported for JBoss 4.X
                logger.log("EJB3 is only supported for the JBoss 4.x application server.");
                valid = false;
                message += "EJB3 is only supported for the JBoss 4.x application server.\r\n";
            }
        }

        if (!valid) {
            return message;
        } else {
            return null;
        }
    }

    private String getEntityWithDuplicateRelationNames() {
        Iterator entities = root.getEntityEjbs().iterator();
        while (entities.hasNext()) {
            Entity entity = (Entity) entities.next();
            Set relationNames = new HashSet();
            for (int i = 0; i < entity.getChildCount(); i++) {
                TreeNode child = entity.getChildAt(i);
                if (child instanceof Relation) {
                    Relation relation = (Relation) child;
                    String relName = relation.getName();
                    if (relationNames.contains(relName)) {
                        tree.setSelectionPath(new TreePath(relation.getPath()));
                        return entity.getRefName();
                    }
                    relationNames.add(relName);
                }
            }
        }
        return null;
    }

    /**
     * Finds any invalid relations, whose referenced foreign tables do not correspond to entity beans.
     *
     * @return List of String[] (never null), where:
     *         [0] is the name of the entity bean containing the relation
     *         [1] is the name of the relation
     *         [2] is the name of the referenced table, for which there is no entity bean.
     */
    private List getEntityWithUnreferencedRelations() {
        ArrayList result = new ArrayList();
        Iterator entities = root.getEntityEjbs().iterator();
        while (entities.hasNext()) {
            Entity entity = (Entity) entities.next();
            for (int i = 0; i < entity.getChildCount(); i++) {
                TreeNode child = entity.getChildAt(i);
                if (child instanceof Relation) {
                    Relation relation = (Relation) child;
                    String referencedTable = relation.getForeignTable();
                    if (entitiesByTableName.get(referencedTable) == null) {
                        result.add(new String[]{entity.getName().toString(), relation.getName(), referencedTable});
                    }
                }
            }
        }
        return result;
    }

    private String getRelationWithInvalidData() {
        Iterator entities = root.getEntityEjbs().iterator();
        while (entities.hasNext()) {
            Entity entity = (Entity) entities.next();
            for (int i = 0; i < entity.getChildCount(); i++) {
                TreeNode child = entity.getChildAt(i);
                if (child instanceof Relation) {
                    Relation relation = (Relation) child;

                    String foreignTable = relation.getForeignTable();
                    if (foreignTable == null || "".equals(foreignTable.trim())) {
                        return "Relation '" + relation + "' within entity '" + entity.getName() +
                                "' has no value for 'foreign table' \n" +
                                "(the name of the table at the foreign side of this relation).  \n" +
                                "Please provide a value!";
                    }

                    if (entitiesByTableName.get(foreignTable) == null) {
                        return null;
                        //this is needed because otherwise this method throws an NPE.
                        //@todo Really should look at improving this validation/error handling mess...
                    }

                    String foreignPkColumn = relation.getForeignColumn();
                    if (foreignPkColumn == null || "".equals(foreignPkColumn.trim())) {
                        return "Relation '" + relation + "' within entity '" + entity.getName() +
                                "' has no value for 'foreign table primary key' \n" +
                                "(the name of the PK imported from table '" + relation.getForeignTable() +
                                "' that represents the foreign side of this relation).  \n" +
                                "Please provide a value!";
                    }

                    boolean found = false;
                    List fields = relation.getRelatedEntity().getFields();
                    Iterator j = fields.iterator();
                    while (j.hasNext()) {
                        Field field = (Field) j.next();
                        if (field.getColumnName().equalsIgnoreCase(foreignPkColumn)) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        return "Relation '" + relation + "' within entity '" + relation.getRelatedEntity().getName() +
                                "' has an invalid value (" + foreignPkColumn + ") for 'foreign table primary key' \n" +
                                "(the name of the PK imported from table '" + relation.getRelatedEntity().getLocalTableName() +
                                "' that represents the foreign side of this relation).  \n" +
                                "Please provide a valid value!";
                    }

                }
            }
        }
        return null;
    }

    /**
     * Helper method to check if there are any relations present in the model.
     */
    private boolean isRelationPresentInModel() {
        Iterator entities = root.getEntityEjbs().iterator();
        while (entities.hasNext()) {
            Entity entity = (Entity) entities.next();
            //for every entity..
            for (int i = 0; i < entity.getChildCount(); i++) {
                TreeNode child = entity.getChildAt(i);
                //for every relation in that entity..
                if (child instanceof Relation) {
                    return true;
                }
            }
        }
        return false;
    }


}
