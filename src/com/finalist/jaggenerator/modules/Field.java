/*   Copyright (C) 2003 Finalist IT Group
 *
 *   This file is part of JAG - the Java J2EE Application Generator
 *
 *   JAG is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *   JAG is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   You should have received a copy of the GNU General Public License
 *   along with JAG; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.finalist.jaggenerator.modules;

import com.finalist.jag.util.TemplateString;
import com.finalist.jaggenerator.Column;
import com.finalist.jaggenerator.JagGenerator;
import com.finalist.jaggenerator.Utils;
import com.finalist.jaggenerator.validation.StrutsValidation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

/**
 * @author hillie
 */
public class Field extends DefaultMutableTreeNode implements JagBean {
    private StrutsValidation validations = new StrutsValidation();
    private Relation relation;
    private Entity parentEntity;
    private boolean previousRequiredState;
    private String oldName;
    private static final ArrayList jdbcTypes = new ArrayList();
    private boolean nullable = true;

    /**
     * Static set of classes for which the UniqueIdGenerator is able to generate primary keys.
     */
    private final static HashSet autogeneratablePrimaryKeyClasses = new HashSet();

    static {
        autogeneratablePrimaryKeyClasses.add("java.lang.Byte");
        autogeneratablePrimaryKeyClasses.add("java.lang.Double");
        autogeneratablePrimaryKeyClasses.add("java.lang.Integer");
        autogeneratablePrimaryKeyClasses.add("java.lang.Long");
        autogeneratablePrimaryKeyClasses.add("java.lang.Short");
        autogeneratablePrimaryKeyClasses.add("java.lang.String");

        java.lang.reflect.Field[] fields = java.sql.Types.class.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            jdbcTypes.add(fields[i].getName());
        }
    }


    /**
     * Creates new form BeanForm
     */
    public Field(Entity parent, Column column) {
        parentEntity = parent;
        try {
            init();
            String name = Utils.format(column.getName());
            nullable = column.isNullable();
            nameText.setText(name);
            oldName = name;
            typeText.setText(getType(column));
            columnNameText.setText(column.getName());
            sqlTypeText.setText(getSqlType(column));
            jdbcTypeComboBox.setSelectedItem(getJdbcType(column));
            if (column.isPrimaryKey()) {
                setPrimaryKey(column.isPrimaryKey());
            }
            if (primaryKeyCheckBox.isSelected()) {
                autoGeneratedCheckBox.setSelected(isPkClassIsAutogeneratable());
            }
            requiredCheckBox.setSelected(!nullable);
            regenerateValidations();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * Use for building up the entity field gui component
     */
    public Field(Entity parent, Element el) {
        parentEntity = parent;
        try {
            init();
            NodeList nl = el.getElementsByTagName("module-data");

            for (int i = 0; i < nl.getLength(); i++) {
                Element child = (Element) nl.item(i);
                String attName = child.getAttribute("name");
                String value = null;
                if (child.getFirstChild() != null)
                    value = child.getFirstChild().getNodeValue();
                if (value != null) {
                    if (attName.equalsIgnoreCase("name")) {
                        nameText.setText(value);
                        oldName = value;
                        continue;
                    }
                    if (attName.equalsIgnoreCase("type")) {
                        typeText.setText(value);
                        continue;
                    }
                    if (attName.equalsIgnoreCase("column-name")) {
                        columnNameText.setText(value);
                        continue;
                    }
                    if (attName.equalsIgnoreCase("required")) {
                        boolean required = "true".equalsIgnoreCase(value);
                        nullable = !required;
                        requiredCheckBox.setSelected(required);
                        continue;
                    }
                    if (attName.equalsIgnoreCase("sql-type")) {
                        sqlTypeText.setText(value);
                        continue;
                    }
                    if (attName.equalsIgnoreCase("jdbc-type")) {
                        jdbcTypeComboBox.setSelectedItem(value);
                        continue;
                    }
                    if (attName.equalsIgnoreCase("primary-key")) {
                        // Don't use the setPrimaryKey method for non-primary keys,
                        // since it will overrule the required and auto-primary key settings.
                        if ("true".equalsIgnoreCase(value)) {
                            setPrimaryKey(true);
                        } else {
                            primaryKeyCheckBox.setSelected(false);
                        }
                        continue;
                    }
                    if (attName.equalsIgnoreCase("auto-primary-key")) {
                        autoGeneratedCheckBox.setSelected("true".equalsIgnoreCase(value)
                                && isPkClassIsAutogeneratable());
                        continue;
                    }
                    if (attName.equalsIgnoreCase("foreign-key")) {
                        setForeignKey("true".equalsIgnoreCase(value.trim()));
                        continue;
                    }
                    if (attName.equalsIgnoreCase("validation-depends")) {
                        if (value != null) {
                            validations.setDependsList(value);
                            validationDependsText.setText(value);
                        } else {
                            validationDependsText.setText("");
                        }
                        continue;
                    }
                    if (attName.equalsIgnoreCase("validation-xml")) {
                        if (value != null) {
                            validations.setXml(value);
                            validationXMLTextArea.setText(value);
                        } else {
                            validationXMLTextArea.setText("");
                        }
                        continue;
                    }
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    public String toString() {
        return nameText.getText();
    }

    public JPanel getPanel() {
        return panel;
    }

    public void getXML(Element el) {
        Document doc = el.getOwnerDocument();
        Element module = doc.createElement("module-data");
        module.setAttribute("name", "field");

        Element name = doc.createElement("module-data");
        name.setAttribute("name", "name");
        if (nameText.getText() != null) {
            if (nameText.getText() != null) {
                name.appendChild(doc.createTextNode(nameText.getText()));
            }
        }
        module.appendChild(name);

        Element type = doc.createElement("module-data");
        type.setAttribute("name", "type");
        if (typeText.getText() != null) {
            type.appendChild(doc.createTextNode(typeText.getText()));
        }
        module.appendChild(type);

        Element columnName = doc.createElement("module-data");
        columnName.setAttribute("name", "column-name");
        if (columnNameText.getText() != null) {
            columnName.appendChild(doc.createTextNode(columnNameText.getText()));
        }
        module.appendChild(columnName);


        Element required = doc.createElement("module-data");
        required.setAttribute("name", "required");
        required.appendChild(doc.createTextNode(Boolean.toString(requiredCheckBox.isSelected())));
        module.appendChild(required);


        Element sqlType = doc.createElement("module-data");
        sqlType.setAttribute("name", "sql-type");
        if (sqlTypeText.getText() != null) {
            sqlType.appendChild(doc.createTextNode(sqlTypeText.getText()));
        }
        module.appendChild(sqlType);

        Element jdbcType = doc.createElement("module-data");
        jdbcType.setAttribute("name", "jdbc-type");
        jdbcType.appendChild(doc.createTextNode(jdbcTypeComboBox.getSelectedItem().toString()));
        module.appendChild(jdbcType);

        Element primaryKey = doc.createElement("module-data");
        primaryKey.setAttribute("name", "primary-key");
        primaryKey.appendChild(doc.createTextNode(Boolean.toString(primaryKeyCheckBox.isSelected())));
        module.appendChild(primaryKey);

        Element autoPrimary = doc.createElement("module-data");
        autoPrimary.setAttribute("name", "auto-primary-key");
        autoPrimary.appendChild(doc.createTextNode(Boolean.toString(autoGeneratedCheckBox.isSelected())));
        module.appendChild(autoPrimary);

        Element foreignKey = doc.createElement("module-data");
        foreignKey.setAttribute("name", "foreign-key");
        foreignKey.appendChild(doc.createTextNode("" + isForeignKey()));
        module.appendChild(foreignKey);

        Element validationDepends = doc.createElement("module-data");
        validationDepends.setAttribute("name", "validation-depends");
        if (validationDependsText.getText() != null) {
            validationDepends.appendChild(doc.createTextNode(validationDependsText.getText()));
        }
        module.appendChild(validationDepends);

        Element validationXml = doc.createElement("module-data");
        validationXml.setAttribute("name", "validation-xml");
        if (validationXMLTextArea.getText() != null) {
            validationXml.appendChild(doc.createTextNode(validationXMLTextArea.getText()));
        }
        module.appendChild(validationXml);

        el.appendChild(module);
    }

    public TemplateString getSqlType() {
        return new TemplateString(sqlTypeText.getText());
    }

    public void setSqlType(String text) {
        sqlTypeText.setText(text);
    }

    public TemplateString getJdbcType() {
        return new TemplateString(jdbcTypeComboBox.getSelectedItem().toString());
    }

    public void setJdbcType(String text) {
        jdbcTypeComboBox.setSelectedItem(text);
    }

    public TemplateString getPrimaryKey() {
        return new TemplateString(Boolean.toString(primaryKeyCheckBox.isSelected()));
    }

    public TemplateString getForeignKey() {
        return new TemplateString(Boolean.toString(isForeignKey()));
    }

    public String getValidationDepends() {
        if (validationDependsText.getText() == null) {
            return "";
        } else {
            return validationDependsText.getText();
        }
    }

    public String getValidationXml() {
        return validationXMLTextArea.getText();
    }

    /**
     * Check if the field is a date field.
     *
     * @return true if the field is a date field
     */
    public String isDate() {
        if ("java.sql.Date".equals(getType())) {
            return "true";
        }
        if ("java.util.Date".equals(getType())) {
            return "true";
        }
        return "false";
    }

    /**
     * Check if the field is a time field.
     *
     * @return true if the field is a time field
     */
    public String isTime() {
        if ("java.sql.Time".equals(getType())) {
            return "true";
        }
        if ("java.sql.Timestamp".equals(getType())) {
            return "true";
        }
        return "false";
    }

    public String getType(Column column) {
        if (column.getSqlType() == null) {
            return "";
        }
        String sqlType = column.getSqlType().toUpperCase();
        int scale = column.getScale();
        int precision = column.getPrecision();
        if (sqlType == null)
            return "";
        if (sqlType.equals("DATE"))
            return "java.sql.Date";
        if (sqlType.equals("BOOL"))
            return "java.lang.Boolean";
        if (sqlType.equals("FLOAT"))
            return "java.lang.Float";
        if (sqlType.equals("DOUBLE"))
            return "java.lang.Double";
        if (sqlType.equals("FLOAT(7)"))
            return "java.lang.Float";
        if (sqlType.equals("FLOAT8"))
            return "java.lang.Double";
        if (contains(sqlType, "NUMERIC") || contains(sqlType, "NUMERIC"))
            return "java.math.BigDecimal";
        if (sqlType.equals("BYTEA")) {
            System.out.println("Mapping the BYTEA binary type to java.sql.Blob. JAG has no support for binary fields.");
            return "java.sql.Blob";
        }
        if ((sqlType.indexOf("TIMESTAMP") != -1) || (sqlType.indexOf("DATETIME") != -1))
            return "java.sql.Timestamp";
        if (sqlType.equals("TIME"))
            return "java.sql.Time";
        if (contains(sqlType, "TINYINT"))
            return "java.lang.Byte";
        if (contains(sqlType, "SMALLINT"))
            return "java.lang.Short";
        if (contains(sqlType, "BIGINT"))
            return "java.lang.Long";
        if (contains(sqlType, "DECIMAL"))
            return "java.math.BigDecimal";
        if (contains(sqlType, "BLOB"))
            return "java.sql.Blob";
        if (contains(sqlType, "SERIAL"))
            return "java.lang.Long";
       if (contains(sqlType, "IDENTITY"))
           return "java.lang.Long";
        if (sqlType.equals("NUMBER") || sqlType.equals("INT") ||
                sqlType.equals("YEAR") ||
                sqlType.indexOf("INT") > -1) {
            if (scale == 0) {
                if (precision == 0) {
                    // this is the case for pseudo columns
                    // like sequences, count(*) etc.
                    // by convention, let's convert them to Integer
                    return "java.lang.Integer";
                }
                if (precision <= 2) {
                    //let it be a byte
                    //
                    return "java.lang.Integer";
                }
                if (precision <= 5) {
                    return "java.lang.Integer";
                }
                if (precision <= 9) {
                    //let it be an int
                    return "java.lang.Integer";
                }
                if (precision <= 18) {
                    if (sqlType.indexOf("INT") != -1) {
                        return "java.lang.Integer";
                    }
                    //let it be a long
                    return "java.lang.Long";
                } else {
                    return "java.math.BigDecimal";
                }
            }
            if (precision + scale <= 12) {
                //return "java.lang.Float";
                return "java.math.BigDecimal";
            }
            if (precision + scale <= 64) {
                return "java.lang.Double";
            } else {
                return "java.math.BigDecimal";
            }
        }

        if (sqlType.indexOf("CHAR") > -1) {
            return "java.lang.String";
        }
        if (sqlType.indexOf("TEXT") > -1) {
            return "java.lang.String";
        }
        System.out.println("unknown sql type: " + sqlType + " Map it to a String.");
        return "java.lang.String";
    }

    public String getJdbcType(Column column) {
        if (column.getSqlType() == null) {
            return "";
        }
        String sqlType = column.getSqlType().toUpperCase();
        int scale = column.getScale();
        int precision = column.getPrecision();
        if (sqlType == null)
            return "";

        if (sqlType.equals("NUMERIC") || sqlType.equals("TINYINT") || sqlType.equals("SMALLINT") ||
                sqlType.equals("DOUBLE") || sqlType.equals("TIMESTAMP") || sqlType.equals("FLOAT") ||
                sqlType.equals("DATE") || sqlType.equals("TIME") || contains(sqlType, "BIGINT") ||
                sqlType.equals("DECIMAL"))
            return sqlType;

        if (contains(sqlType, "CHAR")) {
            return "VARCHAR";
        }
        if (contains(sqlType, "TEXT")) {
            return "VARCHAR";
        }
        if (sqlType.equals("DATETIME"))
            return "TIMESTAMP";
        // Postgress specific:
        if (sqlType.equals("FLOAT(7)"))
            return "FLOAT";
        // Postgress specific:
        if (sqlType.equals("FLOAT8"))
            return "DOUBLE";
        if (sqlType.equals("BYTEA"))
            return "VARBINARY";
        if (contains(sqlType, "BLOB")) {
            return "BLOB";
        }
       if (contains(sqlType, "SERIAL"))
           return "INTEGER";
       if (contains(sqlType, "IDENTITY"))
           return "INTEGER";       
        if (sqlType.equals("NUMBER") || contains(sqlType, "INT") || sqlType.equals("YEAR")) {
            if (scale == 0) {
                if (precision == 0) {
                    // this is the case for pseudo columns
                    // like sequences, count(*) etc.
                    // by convention, let's convert them to Integer
                    return "INTEGER";
                }
                if (precision <= 5) {
                    //let it be a byte
                    return "INTEGER";
                }
                if (precision <= 9) {
                    //let it be an int
                    return "INTEGER";
                }
                if (precision <= 18) {
                    if (sqlType.indexOf("INT") != -1) {
                        return "INTEGER";
                    }
                    //let it be a long
                    return "BIGINT";
                }
            }
            if (precision + scale <= 12) {
                return "DECIMAL";
            }
            if (precision + scale <= 64) {
                return "DOUBLE";
            }
        }

        return "JAVA_OBJECT";
    }

    public String getSqlType(Column column) {
        if (column.getSqlType() == null) {
            return "";
        }
        String sqlType = column.getSqlType().toUpperCase();
        int scale = column.getScale();
        int precision = column.getPrecision();
        int length = column.getLength();
        if (sqlType == null)
            return "";
        if (sqlType.equals("NUMBER") || sqlType.equals("DOUBLE") || contains(sqlType, "INT") ||
                sqlType.equals("YEAR") || sqlType.equals("FLOAT") || sqlType.equals("DECIMAL")) {
            if (precision > 0) {
                sqlType = sqlType + "(" + precision;
                if (scale != 0) {
                    sqlType = sqlType + ", " + scale;
                }
                sqlType = sqlType + ")";
            }
            return sqlType;
        }
        if (sqlType.indexOf("CHAR") > -1) {
            if (length > 0) {
                return sqlType + "(" + length + ")";
            }
        }
        return sqlType;
    }


    /**
     * Helper method to determine the max size of a field.
     * -1 will be returned fields without a size specification.
     *
     * @return max size of a field.
     */
    public int getMaxSize() {
        String jdbcType = getJdbcType().toString();
        int size;
        if ("VARCHAR".equals(jdbcType) || "CHAR".equals(jdbcType) || "LONGVARCHAR".equals(jdbcType)) {
            size = -1;
        } else {
            return -1;
        }
        String sqlType = getSqlType().toString();
        if (sqlType == null) {
            return size;
        }
        int beginIndex = sqlType.indexOf("(");
        int endIndex = sqlType.indexOf(",");
        if (endIndex == -1) {
            endIndex = sqlType.indexOf(")");
        }
        if (beginIndex == -1 || endIndex == -1) {
            return size;
        }
        String strSize = sqlType.substring(beginIndex + 1, endIndex);
        try {
            size = Integer.parseInt(strSize);
            return size;
        } catch (Exception e) {
            return size;
        }
    }

    public String getRefName() {
        return null;
    }


    /**
     * Return true if the field is a numeric field,
     * like Integer, Short etc..
     *
     * @return true if numeric
     */
    public boolean isNumeric() {
        return ("java.lang.Integer".equals(getType())) ||
                ("java.lang.Byte".equals(getType())) ||
                ("java.lang.Long".equals(getType())) ||
                ("java.lang.Short".equals(getType()));
    }


   /**
    * Determine if the field can be used with a sequence.
    * For this the following must apply:
    * - the field needs to be a primary key
    * - the autogenerate primary key checkbox should be on.
    * - the database should be oracle or postgresql with a Serial field.
    *
    * @return true if sequence is allowed
    */
   public boolean isSequenceField() {
   if (isPrimaryKey() && getHasAutoGenPrimaryKey() ) {
      Datasource d = getDatasource();
      String mapping = d.getTypeMapping().getLower();
      if (mapping.startsWith("mysql")) {
         return false;
      }
      // For Oracle there is no autoincrement field. Always use true.
      if (mapping.startsWith("oracle")) {
         return true;
      }
      if (mapping.startsWith("postgresql")) {
         // Postgresql supporst sequence, but if the field is a Serial field, we don't want to use them.
         if (getSqlType().getLower().startsWith("serial")) {
            return false;
         } else {
            return true;
         }
      }
      if (mapping.startsWith("hypersonic")) {
         if (getSqlType().getLower().startsWith("identity")) {
            return false;
         } else {
            return true;
         }
      }
   }
   // By default, return false.
   return false;
   }


   private Config getConfig() {
      List services = JagGenerator.getObjectsFromTree(Config.class);
      for (int i=0; i<services.size(); i++) {
         Config c = (Config) services.get(i);
         return c;
      }
      return null;
   }

   private Datasource getDatasource() {
      List services = JagGenerator.getObjectsFromTree(Datasource.class);
      for (int i=0; i<services.size(); i++) {
         Datasource d = (Datasource) services.get(i);
         return d;
      }
      return null;
   }

    /**
     * Indicates whether the field is part of the primary key.
     *
     * @return <code>true</code> if the field is part of the primary key
     */
    public boolean isPrimaryKey() {
        return primaryKeyCheckBox.isSelected();
    }


    public boolean getHasAutoGenPrimaryKey() {
        return autoGeneratedCheckBox.isSelected();
    }

    public void setHasAutoGenPrimaryKey(boolean value) {
        autoGeneratedCheckBox.setSelected(value);
    }

    /**
     * Setter for this field, which specifies whether or not this Field is a foreign key field within its table.
     *
     * @param foreignKey
     */
    public void setForeignKey(boolean foreignKey) {
        foreignKeyCheckBox.setSelected(foreignKey);
    }

    public boolean isForeignKey() {
        return foreignKeyCheckBox.isSelected();
    }

    /**
     * Returns the class that represents the primary key type
     *
     * @return the class that represents the primary key type
     */
    public String getType() {
        return typeText.getText();
    }

    /**
     * Set the field type
     *
     * @param text type.
     */
    public void setType(String text) {
        typeText.setText(text);
    }

    /**
     * Returns the name of the field
     *
     * @return the name of the field.
     */
    public TemplateString getName() {
        return new TemplateString(nameText.getText());
    }

    /**
     * Sets the name of the field
     *
     * @param name the name of the field.
     */
    public void setName(String name) {
        oldName = nameText.getText();
        nameText.setText(name);
    }

    public String getColumnName() {
        return columnNameText.getText();
    }

    /**
     * Gets the relation, if this field represents a container-managed relation field in its parent entity bean.
     *
     * @return the Relation object, or <code>null</code> if this field doesn't represent a relation.
     */
    public Relation getRelation() {
        return relation;
    }

    public void setRelation(Relation relation) {
        this.relation = relation;
    }

    public boolean isRelation() {
        return relation != null;
    }

    /**
     * Make the nullable field available.
     *
     * @return true if the field is nullable.
     */
    public boolean isNullable() {
        return nullable;
    }

    /**
     * Return true if the field is required, so nullable is true.
     *
     * @return true if the field is required.
     */
    public boolean isRequired() {
        return !nullable;
    }


    /**
     * Return the size of a sql type in case it is a string type. Otherwise return null.
     *
     * @return get the size.
     */
    public String getSize() {
        TemplateString theType = getSqlType();
        if (theType == null) {
            return null;
        }
        List parameters = StrutsValidation.getParams(getSqlType().toString());
        if (getSqlType().toString().indexOf("CHAR") != -1 && !parameters.isEmpty()) {
            return (String) parameters.get(0);
        }
        return null;
    }


    /**
     * Regenerates the Struts validations for this field.
     */
    public void regenerateValidations() {
        validations = new StrutsValidation(sqlTypeText.getText(),
                jdbcTypeComboBox.getSelectedItem().toString(), enforceRequiredValidation());
        if (validations.getDependsList() != null) {
            validationDependsText.setText(validations.getDependsList());
        } else {
            validationDependsText.setText("");
        }
        if (validations.getXml() != null) {
            validationXMLTextArea.setText(validations.getXml());
        } else {
            validationXMLTextArea.setText("");
        }
    }


    private boolean enforceRequiredValidation() {
        //primary key fields are always 'required' (can't be null), but in the webapp we only validate this
        //if the pk field isn't auto-generated.
        return getHasAutoGenPrimaryKey() ? false : requiredCheckBox.isSelected();
    }

    /**
     * A heap of things happen when you set a field as primary key - keep them all here!
     *
     * @param value
     */
    public void setPrimaryKey(boolean value) {
        primaryKeyCheckBox.setSelected(value);
        autoGeneratedCheckBox.setEnabled(value);
        requiredCheckBox.setEnabled(!value);
        if (value) {
            previousRequiredState = requiredCheckBox.isSelected();
            requiredCheckBox.setSelected(true);
        } else {
            requiredCheckBox.setSelected(previousRequiredState);
        }
    }

    public boolean isPkClassIsAutogeneratable() {
        String primaryKeyClass = typeText.getText();
        return autogeneratablePrimaryKeyClasses.contains(primaryKeyClass);
    }

    private void init() {
        initComponents();
        Iterator types = jdbcTypes.iterator();
        while (types.hasNext()) {
            String jdbcType = (String) types.next();
            jdbcTypeComboBox.addItem(jdbcType);
        }
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        panel = new javax.swing.JPanel();
        nameLabel = new javax.swing.JLabel();
        typeLabel = new javax.swing.JLabel();
        columnNameLabel = new javax.swing.JLabel();
        sqlTypeLabel = new javax.swing.JLabel();
        jdbcTypeLabel = new javax.swing.JLabel();
        nameText = new javax.swing.JTextField();
        typeText = new javax.swing.JTextField();
        columnNameText = new javax.swing.JTextField();
        sqlTypeText = new javax.swing.JTextField();
        jPanel1 = new javax.swing.JPanel();
        validationDependsText = new javax.swing.JTextField();
        validationXMLScrollPane = new javax.swing.JScrollPane();
        validationXMLTextArea = new javax.swing.JTextArea();
        validationXMLLabel = new javax.swing.JLabel();
        validationDependsLabel = new javax.swing.JLabel();
        regenerateButton = new javax.swing.JButton();
        jdbcTypeComboBox = new javax.swing.JComboBox();
        checkboxPanel2 = new javax.swing.JPanel();
        autoGeneratedCheckBox = new javax.swing.JCheckBox();
        requiredCheckBox = new javax.swing.JCheckBox();
        checkboxPanel1 = new javax.swing.JPanel();
        primaryKeyCheckBox = new javax.swing.JCheckBox();
        foreignKeyCheckBox = new javax.swing.JCheckBox();

        panel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        nameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        nameLabel.setText("Name: ");
        panel.add(nameLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 10, 90, -1));

        typeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        typeLabel.setText("Type: ");
        panel.add(typeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 40, 90, -1));

        columnNameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        columnNameLabel.setText("Column name: ");
        panel.add(columnNameLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 70, 90, -1));

        sqlTypeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        sqlTypeLabel.setText("SQL-type: ");
        panel.add(sqlTypeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 100, 90, -1));

        jdbcTypeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jdbcTypeLabel.setText("JDBC-type: ");
        panel.add(jdbcTypeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 130, 90, -1));

        nameText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                nameTextFocusLost(evt);
            }
        });

        panel.add(nameText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 10, 260, -1));

        typeText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                typeTextFocusLost(evt);
            }
        });

        panel.add(typeText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 40, 260, -1));

        columnNameText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                columnNameTextFocusLost(evt);
            }
        });

        panel.add(columnNameText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 70, 260, -1));

        sqlTypeText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                sqlTypeTextFocusLost(evt);
            }
        });

        panel.add(sqlTypeText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 100, 260, -1));

        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel1.setBorder(new javax.swing.border.TitledBorder("Struts validations:"));
        validationDependsText.setColumns(46);
        validationDependsText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                validationDependsTextFocusLost(evt);
            }
        });

        jPanel1.add(validationDependsText, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 30, 290, -1));

        validationXMLTextArea.setColumns(48);
        validationXMLTextArea.setFont(new java.awt.Font("Lucida Console", 0, 10));
        validationXMLTextArea.setRows(6);
        validationXMLTextArea.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                validationXMLTextAreaFocusLost(evt);
            }
        });

        validationXMLScrollPane.setViewportView(validationXMLTextArea);

        jPanel1.add(validationXMLScrollPane, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 59, -1, 90));

        validationXMLLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        validationXMLLabel.setText("Validation XML: ");
        jPanel1.add(validationXMLLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(-20, 60, 110, 20));

        validationDependsLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        validationDependsLabel.setText("Validations: ");
        jPanel1.add(validationDependsLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(-20, 30, 110, -1));

        regenerateButton.setText("Regenerate validations");
        regenerateButton.setEnabled(false);
        regenerateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                regenerateButtonActionPerformed(evt);
            }
        });

        jPanel1.add(regenerateButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 170, -1, -1));

        panel.add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 240, 400, 200));

        jdbcTypeComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jdbcTypeComboBoxActionPerformed(evt);
            }
        });

        panel.add(jdbcTypeComboBox, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 130, 260, -1));

        checkboxPanel2.setLayout(new java.awt.BorderLayout());

        autoGeneratedCheckBox.setText("Auto-generated primary key:");
        autoGeneratedCheckBox.setEnabled(false);
        autoGeneratedCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        autoGeneratedCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        autoGeneratedCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                autoGeneratedCheckBoxActionPerformed(evt);
            }
        });

        checkboxPanel2.add(autoGeneratedCheckBox, java.awt.BorderLayout.SOUTH);

        requiredCheckBox.setText("Required (not nullable):");
        requiredCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        requiredCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        requiredCheckBox.setMaximumSize(new java.awt.Dimension(186, 24));
        requiredCheckBox.setMinimumSize(new java.awt.Dimension(186, 24));
        requiredCheckBox.setPreferredSize(new java.awt.Dimension(186, 24));
        requiredCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                requiredCheckBoxActionPerformed(evt);
            }
        });

        checkboxPanel2.add(requiredCheckBox, java.awt.BorderLayout.NORTH);

        panel.add(checkboxPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 170, 190, 50));

        checkboxPanel1.setLayout(new java.awt.BorderLayout());

        primaryKeyCheckBox.setText("Primary key:");
        primaryKeyCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        primaryKeyCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                primaryKeyCheckBoxActionPerformed(evt);
            }
        });

        checkboxPanel1.add(primaryKeyCheckBox, java.awt.BorderLayout.NORTH);

        foreignKeyCheckBox.setText("Foreign key:");
        foreignKeyCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        foreignKeyCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                foreignKeyCheckBoxActionPerformed(evt);
            }
        });

        checkboxPanel1.add(foreignKeyCheckBox, java.awt.BorderLayout.SOUTH);

        panel.add(checkboxPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 170, 160, 50));

    }
    // </editor-fold>//GEN-END:initComponents

    private void jdbcTypeComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jdbcTypeComboBoxActionPerformed
        JagGenerator.stateChanged(false);
        regenerateButton.setEnabled(true);
    }//GEN-LAST:event_jdbcTypeComboBoxActionPerformed

    private void autoGeneratedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_autoGeneratedCheckBoxActionPerformed
        if (autoGeneratedCheckBox.isSelected() && !isPkClassIsAutogeneratable()) {
            JagGenerator.logToConsole("Can't autogenerate primary keys with class type '" + typeText.getText() + "'!");
            autoGeneratedCheckBox.setSelected(false);
        }
    }//GEN-LAST:event_autoGeneratedCheckBoxActionPerformed

    private void regenerateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_regenerateButtonActionPerformed
        regenerateValidations();
        regenerateButton.setEnabled(false);
    }//GEN-LAST:event_regenerateButtonActionPerformed

    private void requiredCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_requiredCheckBoxActionPerformed
        JagGenerator.stateChanged(false);
        regenerateButton.setEnabled(true);
    }//GEN-LAST:event_requiredCheckBoxActionPerformed

    private void validationXMLTextAreaFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_validationXMLTextAreaFocusLost
        JagGenerator.stateChanged(false);
    }//GEN-LAST:event_validationXMLTextAreaFocusLost

    private void validationDependsTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_validationDependsTextFocusLost
        JagGenerator.stateChanged(false);
    }//GEN-LAST:event_validationDependsTextFocusLost

    private void foreignKeyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_foreignKeyCheckBoxActionPerformed
        JagGenerator.stateChanged(false);
        regenerateButton.setEnabled(true);
    }//GEN-LAST:event_foreignKeyCheckBoxActionPerformed

    private void primaryKeyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_primaryKeyCheckBoxActionPerformed
        boolean checked = primaryKeyCheckBox.isSelected();
        setPrimaryKey(checked);

        //tell the parent entity bean that its primary key status has changed..
        if (checked) {
            parentEntity.setPrimaryKey(this);
        } else {
            parentEntity.unsetPrimaryKey(this);
        }

        JagGenerator.stateChanged(false);
        regenerateButton.setEnabled(true);
    }//GEN-LAST:event_primaryKeyCheckBoxActionPerformed

    private void sqlTypeTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sqlTypeTextFocusLost
        JagGenerator.stateChanged(false);
        regenerateButton.setEnabled(true);
    }//GEN-LAST:event_sqlTypeTextFocusLost

    private void columnNameTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_columnNameTextFocusLost
        JagGenerator.stateChanged(false);
    }//GEN-LAST:event_columnNameTextFocusLost

    private void typeTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_typeTextFocusLost
        JagGenerator.stateChanged(false);
    }//GEN-LAST:event_typeTextFocusLost

    private void nameTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_nameTextFocusLost
        if (!nameText.getText().equals(oldName)) {
            parentEntity.notifyRelationsThatFieldNameChanged(oldName, nameText.getText());
            oldName = nameText.getText();
        }
        JagGenerator.stateChanged(true);
    }//GEN-LAST:event_nameTextFocusLost

    private boolean contains(String s, String sub) {
        return s.indexOf(sub) > -1;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    public javax.swing.JCheckBox autoGeneratedCheckBox;
    private javax.swing.JPanel checkboxPanel1;
    private javax.swing.JPanel checkboxPanel2;
    private javax.swing.JLabel columnNameLabel;
    private javax.swing.JTextField columnNameText;
    public javax.swing.JCheckBox foreignKeyCheckBox;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox jdbcTypeComboBox;
    private javax.swing.JLabel jdbcTypeLabel;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JTextField nameText;
    private javax.swing.JPanel panel;
    public javax.swing.JCheckBox primaryKeyCheckBox;
    private javax.swing.JButton regenerateButton;
    public javax.swing.JCheckBox requiredCheckBox;
    private javax.swing.JLabel sqlTypeLabel;
    private javax.swing.JTextField sqlTypeText;
    private javax.swing.JLabel typeLabel;
    private javax.swing.JTextField typeText;
    private javax.swing.JLabel validationDependsLabel;
    public javax.swing.JTextField validationDependsText;
    private javax.swing.JLabel validationXMLLabel;
    private javax.swing.JScrollPane validationXMLScrollPane;
    private javax.swing.JTextArea validationXMLTextArea;
    // End of variables declaration//GEN-END:variables
}

